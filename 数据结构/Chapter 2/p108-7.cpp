// use c++20 standard#include <algorithm>#include <format>#include <iostream>#include <optional>#include <vector>#pragma warning(disable : 4554 4224 4267)#define TYPE_BIT(TYPE) (sizeof(TYPE) << 3)using namespace std;template <class _Tp>inline constexpr _Tp get_bits(const _Tp& value, size_t first, size_t last) {    return ((_Tp{ 1 } << last - first) - _Tp{ 1 }) << (TYPE_BIT(_Tp) - last) & value;}// operate indextemplate <class T>inline constexpr bool get_bit(const T& value, size_t index) {    return ((T{ 1 } << TYPE_BIT(T) - index - 1) & value) != 0;}template <class T>inline constexpr void clear_bit(T& value, size_t index) {    value &= ~(T{ 1 } << TYPE_BIT(T) - index - 1);}template <class T>inline constexpr void flip_bit(T& value, uint32_t index) {    value ^= T{ 1 } << TYPE_BIT(T) - index - 1;}template <class T>inline constexpr void set_bit(T& value, uint32_t index, bool val = true) {    if (get_bit(value, index) ^ val)        flip_bit(value, index);}size_t to_block_index(size_t r, size_t c, size_t col) { return (r * col + c) / sizeof(uint8_t); }size_t to_bit_index(size_t r, size_t c, size_t col) { return (r * col + c) % sizeof(uint8_t); }struct Item {    size_t r, c;    int    value;};class MappingMatrix {public:    class reference;    class const_reference {        friend class MappingMatrix;    public:        [[nodiscard]] bool operator==(const const_reference& rhs) const noexcept { return std::addressof(mat) == std::addressof(rhs.mat) && r == rhs.r && c == rhs.c; }  // for iterators        [[nodiscard]] bool operator!=(const const_reference& rhs) const noexcept { return !(*this == rhs); }        operator bool() const { return get_bit(get_byte(), get_bit_index()); }        bool operator~() const { return static_cast<bool>(*this) == 0; }        explicit operator reference() { return reference(mat, r, c); }    protected:        const_reference(const MappingMatrix& mat, const size_t r, const size_t c) : mat(const_cast<MappingMatrix&>(mat)), r(r), c(c) {}        inline uint8_t& get_byte() const { return mat.bits[to_block_index(r, c, mat.col)]; }        inline size_t   get_bit_index() const { return to_bit_index(r, c, mat.col); }        MappingMatrix& mat;        mutable size_t r, c;    };    class reference : public const_reference {        friend class MappingMatrix;        using Base = const_reference;        using Base::c;        using Base::mat;        using Base::r;        reference(MappingMatrix& mat, const size_t r, size_t c) : Base(mat, r, c) {}    public:        reference& flip() { return *this = ~*this; }        void swap(reference& ref) {            if (*this ^ ref)                flip(), ref.flip();        }        friend void swap(reference& x, reference& y) { x.swap(y); }        reference& operator=(bool x) {            set_bit(get_byte(), get_bit_index(), x);            return *this;        }        reference& operator=(const reference& rhs) {            set_bit(get_byte(), get_bit_index(), static_cast<bool>(rhs));            return *this;        }        reference& operator|=(bool x) {            if (x)                get_byte() |= uint8_t{ 1 } << (TYPE_BIT(uint8_t) - get_bit_index() - 1);            return *this;        }        reference& operator&=(bool x) {            if (!x)                clear_bit(get_byte(), get_bit_index());            return *this;        }        reference& operator^=(bool x) {            if (x)                get_byte() ^= uint8_t{ 1 } << (TYPE_BIT(uint8_t) - get_bit_index() - 1);            return *this;        }        reference& operator-=(bool x) {            if (x)                clear_bit(get_byte(), get_bit_index());            return *this;        }    };    MappingMatrix(size_t row, size_t col) : row(row), col(col), bits(ceil(static_cast<double>(row* col) / sizeof(uint8_t))) {}    MappingMatrix(const MappingMatrix&) = default;    MappingMatrix(MappingMatrix&&) = default;    void resize(size_t newRow, size_t newCol) {        bits.resize(ceil(static_cast<double>(newRow * newCol) / sizeof(uint8_t)));        if (row && col) {            // TODO        }        row = newRow, col = newCol;    }    reference at(size_t r, size_t c) {        if (r >= row || c >= col)            throw out_of_range("invalid matrix index");        return reference(*this, r, c);    }    const_reference at(size_t r, size_t c) const {        if (r >= row || c >= col)            throw out_of_range("invalid matrix index");        return const_reference(*this, r, c);    }    size_t rowSize() const { return row; }    size_t colSize() const { return col; }    size_t count(size_t from_r, size_t from_c, size_t to_r, size_t to_c) const {        static const char* const bits_table = "\0\1\1\2\1\2\2\3\1\2\2\3\2\3\3\4"            "\1\2\2\3\2\3\3\4\2\3\3\4\3\4\4\5"            "\1\2\2\3\2\3\3\4\2\3\3\4\3\4\4\5"            "\2\3\3\4\3\4\4\5\3\4\4\5\4\5\5\6"            "\1\2\2\3\2\3\3\4\2\3\3\4\3\4\4\5"            "\2\3\3\4\3\4\4\5\3\4\4\5\4\5\5\6"            "\2\3\3\4\3\4\4\5\3\4\4\5\4\5\5\6"            "\3\4\4\5\4\5\5\6\4\5\5\6\5\6\6\7"            "\1\2\2\3\2\3\3\4\2\3\3\4\3\4\4\5"            "\2\3\3\4\3\4\4\5\3\4\4\5\4\5\5\6"            "\2\3\3\4\3\4\4\5\3\4\4\5\4\5\5\6"            "\3\4\4\5\4\5\5\6\4\5\5\6\5\6\6\7"            "\2\3\3\4\3\4\4\5\3\4\4\5\4\5\5\6"            "\3\4\4\5\4\5\5\6\4\5\5\6\5\6\6\7"            "\3\4\4\5\4\5\5\6\4\5\5\6\5\6\6\7"            "\4\5\5\6\5\6\6\7\5\6\6\7\6\7\7\b";        size_t count = 0;        size_t from_idx = to_block_index(from_r, from_c, col), to_idx = to_block_index(to_r, to_c, col);        size_t from_bit_idx = to_bit_index(from_r, from_c, col), to_bit_idx = to_bit_index(to_r, to_c, col);        if (from_idx == to_idx) {            count += bits_table[get_bits(bits[from_idx], from_bit_idx, to_bit_idx + 1)];        }        else if (from_idx < to_idx) {            count += bits_table[get_bits(bits[from_idx], from_bit_idx, TYPE_BIT(uint8_t))];            for (int i = 1; i < to_idx; ++i)                count += bits_table[bits[from_idx + i]];            count += bits_table[get_bits(bits[to_idx], 0, to_bit_idx + 1)];        }        return count;    }    size_t count(size_t r, size_t c) const { return count(0, 0, r, c); }    MappingMatrix& operator=(const MappingMatrix&) = default;    MappingMatrix& operator=(MappingMatrix&&) = default;private:    vector<uint8_t> bits;    size_t          row, col;};class SparseMatrix {public:    SparseMatrix(size_t row, size_t col) : mat(row, col) {}    SparseMatrix(const SparseMatrix&) = default;    SparseMatrix(SparseMatrix&&) noexcept = default;    template <class Iter, class = enable_if_t<is_same_v<typename iterator_traits<Iter>::value_type, Item>>>    SparseMatrix(Iter first, Iter last, size_t row = 0, size_t col = 0) : mat(row, col) {        if (row == 0) {            if (is_same_v<typename iterator_traits<Iter>::iterator_category, forward_iterator_tag>)                throw invalid_argument("default row/col requires non forward iterator");            row = max_element(first, last, [](const Item& a, const Item& b) { return a.r < b.r; })->r + 1;        }        if (col == 0) {            if (is_same_v<typename iterator_traits<Iter>::iterator_category, forward_iterator_tag>)                throw invalid_argument("default row/col requires non forward iterator");            col = max_element(first, last, [](const Item& a, const Item& b) { return a.c < b.c; })->c + 1;        }        mat.resize(row, col);        for (; first != last; ++first) {            mat.at(first->r, first->c) = true;            values.push_back(first->value);        }    }    optional<int> at(size_t r, size_t c) const {        if (mat.at(r, c) == false)            return {};        else            return getValueAt(r, c);    }    SparseMatrix transpose() const {        SparseMatrix res(colSize(), rowSize());        for (size_t r = 0; r < rowSize(); ++r) {            for (size_t c = 0; c < colSize(); ++c) {                if (mat.at(r, c)) {                    res.mat.at(c, r) = true;                    res.values.push_back(getValueAt(r, c));                }            }        }        return res;    }    size_t rowSize() const { return mat.rowSize(); }    size_t colSize() const { return mat.colSize(); }    SparseMatrix& operator=(const SparseMatrix& smat) = default;    SparseMatrix& operator=(SparseMatrix&& smat) noexcept = default;    SparseMatrix operator+(const SparseMatrix& smat) const {        SparseMatrix tmp(*this);        return tmp += smat;    }    SparseMatrix operator+=(const SparseMatrix& smat) {        if (rowSize() != smat.rowSize() || colSize() != smat.colSize())            throw invalid_argument("add operation requires the same size");        size_t value_index = 0, smat_index = 0;        for (size_t r = 0; r < smat.rowSize(); ++r) {            for (size_t c = 0; c < smat.colSize(); ++c) {                if (smat.mat.at(r, c)) {                    if (mat.at(r, c))                        values[value_index] += smat.values[smat_index];                    else {                        values.insert(values.begin() + value_index, smat.values[smat_index]);                        mat.at(r, c) = true;                    }                    smat_index++, value_index++;                }                else if (mat.at(r, c))                    value_index++;            }        }        return *this;    }    SparseMatrix operator*(const SparseMatrix& smat) const {        if (colSize() != smat.rowSize())            throw invalid_argument("multiplication requires this.col == that.row");        SparseMatrix product(rowSize(), smat.colSize());        for (size_t r = 0; r < rowSize(); ++r)            for (size_t c = 0; c < smat.colSize(); ++c) {                int sum = 0;                for (size_t k = 0; k < colSize(); ++k)                    if (mat.at(r, k) && smat.mat.at(k, c))                        sum += getValueAt(r, k) * smat.getValueAt(k, c);                if (sum) {                    product.values.push_back(sum);                    product.mat.at(r, c) = true;                }            }        return product;    }    SparseMatrix operator*=(const SparseMatrix& smat) { return *this = *this * smat; }    friend ostream& operator<<(ostream& os, const SparseMatrix& m) {        for (size_t r = 0; r < m.rowSize(); ++r) {            for (size_t c = 0; c < m.colSize(); ++c) {                if (m.mat.at(r, c))                    os << format("{:^5},", m.getValueAt(r, c));                else                    os << "     ,";            }            os << endl;        }        return os;    }private:    int getValueAt(size_t r, size_t c) const { return values[mat.count(r, c) - 1]; }    MappingMatrix mat;    vector<int> values;    // vector<size_t> ra; //no need};int main() {    static_assert(!(__cplusplus >= 201103L && __cplusplus < 202002L), "requires c++20 standard or newer");    vector v{ Item{ 0, 3, 10 }, Item{ 1, 2, 5 }, Item{ 1, 3, 6 }, Item{ 2, 2, 1 }, Item{ 2, 3, 10 } };    vector u{ Item{ 0, 2, 4 }, Item{ 1, 3, 1 }, Item{ 2, 2, 2 } };    SparseMatrix m(v.begin(), v.end()), n(u.begin(), u.end(), m.rowSize(), m.colSize());    cout << "matrix m:" << endl;    cout << m << endl;    cout << "matrix n:" << endl;    cout << n << endl;    cout << "sum of m + n:" << endl;    cout << m + n << endl;    cout << "transpose of m:" << endl;    cout << m.transpose() << endl;    cout << "product of m x m^T" << endl;    cout << m * m.transpose() << endl;}